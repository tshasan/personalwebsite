<html lang="en">
<head>
    <meta charset="utf-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>My first three.js app</title>
    <!-- Include Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="absolute inset-0 -z-10 h-full w-full bg-white bg-[radial-gradient(#e5e7eb_1px,transparent_1px)] [background-size:16px_16px]">

    <nav id="info" class="p-4 w-full">
        <a href="/" class="text-lg font-medium text-black hover:text-gray-300">Home</a>
    </nav>

    <p class="mb-4">This JavaScript code snippet is designed to create a 3D ASCII art effect using the Three.js library.</p>

    <!-- Container for the Three.js scene -->
    <div id="scene-container" class="w-1/2 h-1/2 relative mx-auto bg-black text-white"></div>

    <script>
        import * as THREE from 'three';
        import { AsciiEffect } from 'three/examples/jsm/effects/AsciiEffect.js';
        import { TrackballControls } from 'three/examples/jsm/controls/TrackballControls.js';

        // Define variables
        let camera, controls, scene, renderer, effect;
        let mesh;

        // Define geometries
        const geometries = {
            cube: new THREE.BoxGeometry(200, 200, 200),
            torus: new THREE.TorusGeometry(100, 30, 16, 100),
            prism: new THREE.CylinderGeometry(100, 100, 200, 3),
            torusknot: new THREE.TorusKnotGeometry(10, 3, 100, 16)
        };

        // Set current geometry
        let currentGeometry = geometries.cube;

        // Initialize and animate
        init();
        animate();

        function init() {
            setupScene();
            setupRenderer();
            setupControls();
            setupButtons();
            window.addEventListener('resize', debounce(onWindowResize, 250), false);
            document.addEventListener('keydown', onDocumentKeyDown, false);
        }

        function setupScene() {
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.set(0, 150, 500);
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0, 0, 0);
            setupLights();
            mesh = new THREE.Mesh(currentGeometry, new THREE.MeshNormalMaterial());
            scene.add(mesh);
        }

        function setupLights() {
            const light1 = new THREE.PointLight(0xffffff, 1.5);
            light1.position.set(500, 500, 500);
            scene.add(light1);

            const light2 = new THREE.PointLight(0xffffff, 0.5);
            light2.position.set(-500, -500, -500);
            scene.add(light2);
        }

        function setupRenderer() {
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            // Append the renderer to the scene container instead of the body
            effect = new AsciiEffect(renderer, ' .:-+*=%@#', { invert: true });
            effect.setSize(window.innerWidth, window.innerHeight);
            // Append the effect to the scene container instead of the body
            document.getElementById('scene-container').appendChild(effect.domElement);
        }

        function setupControls() {
            controls = new TrackballControls(camera, effect.domElement);
        }

        function setupButtons() {
            const buttonContainer = document.createElement('div');
            buttonContainer.innerHTML = `
                <button id="cubeButton">Cube</button>
                <button id="torusButton">Torus</button>
                <button id="prismButton">Prism</button>
                <button id="torusknotButton">Torus Knot</button>
            `;
            document.body.appendChild(buttonContainer);

            buttonContainer.addEventListener('click', (event) => {
                if (event.target.tagName === 'BUTTON') {
                    const geometryKey = event.target.id.replace('Button', '');
                    changeGeometry(geometryKey);
                }
            });
        }

        function onWindowResize() {
            const container = document.getElementById('scene-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
            effect.setSize(width, height);
        }

        function animate() {
            requestAnimationFrame(animate);
            render();
        }

        function render() {
            controls.update();
            effect.render(scene, camera);
        }

        function onDocumentKeyDown(event) {
            switch (event.keyCode) {
            case 37: // left arrow key
            mesh.rotation.y -= 0.05;
            break;
            case 38: // up arrow key
            mesh.rotation.x -= 0.05;
            break;
            case 39: // right arrow key
            mesh.rotation.y += 0.05;
            break;
            case 40: // down arrow key
            mesh.rotation.x += 0.05;
            break;
            case 187: // '+' key
            case 107: // numpad '+' key
            camera.fov = Math.max(10, camera.fov - 5);
            camera.updateProjectionMatrix();
            break;
            case 189: // '-' key
            case 109: // numpad '-' key
            camera.fov = Math.min(100, camera.fov + 5);
            camera.updateProjectionMatrix();
            break;
            }
        }


        function changeGeometry(geometryKey) {
            if (currentGeometry !== geometries[geometryKey]) {
                currentGeometry = geometries[geometryKey];
                mesh.geometry.dispose(); // Dispose the old geometry
                mesh.geometry = currentGeometry;
            }
        }

        function debounce(func, wait, immediate) {
            let timeout;
            return function executedFunction() {
                const context = this;
                const args = arguments;
                
                const later = function() {
                    timeout = null;
                    if (!immediate) func.apply(context, args);
                };

                const callNow = immediate && !timeout;
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
                
                if (callNow) func.apply(context, args);
            };
        }

        onWindowResize();
        window.addEventListener('resize', onWindowResize, false);
        
 
    </script>

</body>
</html>
